"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const constants_1 = require("./util/constants");
const util_2 = require("./util/util");
const DeserializerError_1 = require("./errors/DeserializerError");
const float64Array = new Float64Array(1);
const uInt8Float64Array = new Uint8Array(float64Array.buffer);
class Deserializer {
    constructor(buffer) {
        this.offset = 0;
        this._objectIDs = new Map();
        this._buffer = buffer;
    }
    get finished() {
        return this.offset === this._buffer.length;
    }
    clean() {
        this._buffer = null;
        this.offset = 0;
        this._objectIDs.clear();
    }
    read() {
        const type = this.read8();
        switch (type) {
            case constants_1.BinaryTokens.Null: return null;
            case constants_1.BinaryTokens.PBigInt: return this.readValueBigInt(false);
            case constants_1.BinaryTokens.NBigInt: return this.readValueBigInt(true);
            case constants_1.BinaryTokens.Boolean: return Boolean(this.read8());
            case constants_1.BinaryTokens.String: return this.readString();
            case constants_1.BinaryTokens.Undefined: return undefined;
            case constants_1.BinaryTokens.UnsignedByte: return this.read8();
            case constants_1.BinaryTokens.SignedByte: return -this.read8();
            case constants_1.BinaryTokens.UnsignedInt32: return this.read32();
            case constants_1.BinaryTokens.SignedInt32: return -this.read32();
            case constants_1.BinaryTokens.UnsignedFloat64: return this.readF64();
            case constants_1.BinaryTokens.SignedFloat64: return -this.readF64();
            case constants_1.BinaryTokens.Array: return this.readValueArray();
            case constants_1.BinaryTokens.EmptyArray: return this.createObjectID([]);
            case constants_1.BinaryTokens.ObjectReference: return this._objectIDs.get(this.read32());
            case constants_1.BinaryTokens.Date: return this.createObjectID(new Date(this.readF64()));
            // eslint-disable-next-line no-new-wrappers
            case constants_1.BinaryTokens.BooleanObject: return this.createObjectID(new Boolean(this.read8()));
            // eslint-disable-next-line no-new-wrappers
            case constants_1.BinaryTokens.NumberObject: return this.createObjectID(new Number(this.readF64()));
            // eslint-disable-next-line no-new-wrappers
            case constants_1.BinaryTokens.StringObject: return this.createObjectID(new String(this.readString()));
            case constants_1.BinaryTokens.EmptyObject: return this.createObjectID({});
            case constants_1.BinaryTokens.Object: return this.readValueObject();
            case constants_1.BinaryTokens.RegExp: return this.createObjectID(new RegExp(this.readString(), util_2.RegExps.flagsFromInteger(this.read8())));
            case constants_1.BinaryTokens.Map: return this.readValueMap();
            case constants_1.BinaryTokens.EmptyMap: return this.createObjectID(new Map());
            case constants_1.BinaryTokens.Set: return this.readValueSet();
            case constants_1.BinaryTokens.EmptySet: return this.createObjectID(new Set());
            case constants_1.BinaryTokens.ArrayBuffer: return this.readValueArrayBuffer();
            case constants_1.BinaryTokens.WeakMap: return this.createObjectID(new WeakMap());
            case constants_1.BinaryTokens.WeakSet: return this.createObjectID(new WeakSet());
            case constants_1.BinaryTokens.Int8Array:
            case constants_1.BinaryTokens.Uint8Array:
            case constants_1.BinaryTokens.Uint8ClampedArray:
            case constants_1.BinaryTokens.Int16Array:
            case constants_1.BinaryTokens.Uint16Array:
            case constants_1.BinaryTokens.Int32Array:
            case constants_1.BinaryTokens.Uint32Array:
            case constants_1.BinaryTokens.Float32Array:
            case constants_1.BinaryTokens.Float64Array:
            case constants_1.BinaryTokens.DataView: return this.readValueTypedArray(type);
            default: throw new DeserializerError_1.DeserializerError(`Unknown type received: ${type}`, DeserializerError_1.DeserializerReason.UnknownType);
        }
    }
    readValueTypedArray(token) {
        // Read the byte length, then create a shared ArrayBuffer for the desired
        // typedArray and an Uint8Array which we write to.
        const byteLength = this.read32();
        this.ensureBytes(byteLength);
        let value;
        // Fast-path if we are deserializing an Uint8Array
        if (token === constants_1.BinaryTokens.Uint8Array) {
            value = this._buffer.subarray(this.offset, this.offset + byteLength);
        }
        else {
            const buffer = new ArrayBuffer(byteLength);
            const ctor = util_2.TypedArrays.typedArrayTagToConstructor.get(token);
            value = new ctor(buffer);
            new Uint8Array(buffer).set(this._buffer.subarray(this.offset, this.offset + byteLength));
        }
        this.offset += byteLength;
        return this.createObjectID(value);
    }
    readValueArrayBuffer() {
        const value = this.createObjectID(new ArrayBuffer(this.read32()));
        const uint8Array = new Uint8Array(value);
        for (let i = 0, max = uint8Array.length; i < max; i++) {
            uint8Array[i] = this.read8();
        }
        return value;
    }
    readValueSet() {
        const value = this.createObjectID(new Set());
        while (!this.readNullTerminator()) {
            value.add(this.read());
        }
        return value;
    }
    readValueMap() {
        const value = this.createObjectID(new Map());
        while (!this.readNullTerminator()) {
            value.set(this.read(), this.read());
        }
        return value;
    }
    readValueObject() {
        const value = this.createObjectID({});
        while (!this.readNullTerminator()) {
            const entryKey = this.read();
            const entryValue = this.read();
            value[entryKey] = entryValue;
        }
        return value;
    }
    readValueArray() {
        const value = this.createObjectID([]);
        let i = 0;
        while (!this.readNullTerminator()) {
            if (this.read8() !== constants_1.BinaryTokens.Hole) {
                this.offsetBack();
                value[i] = this.read();
            }
            ++i;
        }
        // This is required for holey arrays
        value.length = i;
        return value;
    }
    readString() {
        const end = this._buffer.indexOf(constants_1.BinaryTokens.NullPointer, this.offset);
        if (end === -1) {
            throw new DeserializerError_1.DeserializerError('Found End-Of-Buffer, expecting a `NullTerminator` before.', DeserializerError_1.DeserializerReason.UnexpectedEndOfBuffer);
        }
        const sub = this._buffer.subarray(this.offset, end);
        const str = Deserializer._textDecoder.decode(sub);
        this.offset = end + 1;
        return str;
    }
    readValueBigInt(sign) {
        const byteLength = this.read32();
        let value = util_2.BigIntegers.ZERO;
        let b = util_2.BigIntegers.ONE;
        for (let i = 0; i < byteLength; i++) {
            const digit = this.read8();
            value += BigInt(digit) * b;
            b <<= util_2.BigIntegers.EIGHT;
        }
        return sign ? -value : value;
    }
    readNullTerminator() {
        if (this.watch8() === constants_1.BinaryTokens.NullPointer) {
            ++this.offset;
            return true;
        }
        else if (this.finished) {
            throw new DeserializerError_1.DeserializerError('Found End-Of-Buffer, expecting a `NullTerminator` before.', DeserializerError_1.DeserializerReason.UnexpectedEndOfBuffer);
        }
        return false;
    }
    createObjectID(value) {
        this._objectIDs.set(this._objectIDs.size, value);
        return value;
    }
    offsetBack() {
        --this.offset;
    }
    watch8() {
        return this._buffer[this.offset];
    }
    read8() {
        this.ensureBytes(1);
        return this._buffer[this.offset++];
    }
    read32() {
        this.ensureBytes(4);
        return (this._buffer[this.offset++] * (2 ** 24)) +
            (this._buffer[this.offset++] * (2 ** 16)) +
            (this._buffer[this.offset++] * (2 ** 8)) +
            this._buffer[this.offset++];
    }
    readF64() {
        this.ensureBytes(8);
        uInt8Float64Array[0] = this._buffer[this.offset++];
        uInt8Float64Array[1] = this._buffer[this.offset++];
        uInt8Float64Array[2] = this._buffer[this.offset++];
        uInt8Float64Array[3] = this._buffer[this.offset++];
        uInt8Float64Array[4] = this._buffer[this.offset++];
        uInt8Float64Array[5] = this._buffer[this.offset++];
        uInt8Float64Array[6] = this._buffer[this.offset++];
        uInt8Float64Array[7] = this._buffer[this.offset++];
        return float64Array[0];
    }
    ensureBytes(amount) {
        if (this.offset + amount > this._buffer.length) {
            throw new DeserializerError_1.DeserializerError(`Found End-Of-Buffer, expecting ${amount} byte(s).`, DeserializerError_1.DeserializerReason.UnexpectedEndOfBuffer);
        }
    }
}
Deserializer._textDecoder = new util_1.TextDecoder();
exports.Deserializer = Deserializer;
//# sourceMappingURL=Deserializer.js.map