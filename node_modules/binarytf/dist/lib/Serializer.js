"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("./util/constants");
const util_1 = require("./util/util");
const SerializerError_1 = require("./errors/SerializerError");
const util_2 = require("util");
// Immutable
const MIN_INT8 = -127;
const MAX_INT8 = 255;
const MIN_INT32 = -2147483647;
const MAX_INT32 = 4294967295;
// Mutable
const float64Array = new Float64Array(1);
const uInt8Float64Array = new Uint8Array(float64Array.buffer);
class Serializer {
    constructor(data, onUnsupported = null) {
        this._buffer = new Uint8Array(16);
        this._offset = 0;
        this._objectIDs = new Map();
        this._handlingUnsupported = false;
        this._data = data;
        this.onUnsupported = onUnsupported;
    }
    process() {
        this.parse(this._data);
        const temp = this._buffer.subarray(0, this._offset);
        this._data = null;
        this._offset = 0;
        this._objectIDs.clear();
        this._buffer = null;
        return temp;
    }
    parse(value, hint = typeof value) {
        switch (hint) {
            case constants_1.BinaryPrimitives.BigInt: return this.parseBigInt(value);
            case constants_1.BinaryPrimitives.Boolean: return this.parseBoolean(value);
            case constants_1.BinaryPrimitives.Number: return this.parseNumber(value);
            case constants_1.BinaryPrimitives.Object: return this.parseObject(value);
            case constants_1.BinaryPrimitives.String: return this.parseString(value);
            case constants_1.BinaryPrimitives.Undefined: return this.parseUndefined();
            default: return this.handleUnsupported(value, hint);
        }
    }
    handleUnsupported(value, hint) {
        // If there's an onUnsupported handler, try to call it
        if (this.onUnsupported) {
            // If the serializer was handling an unsupported type, abort the serialization
            // as it's most likely an error in the return type of the handler.
            if (this._handlingUnsupported) {
                throw new SerializerError_1.SerializerError('The modified value was not serializable.', SerializerError_1.SerializerReason.UnsupportedSerializedType);
            }
            // Set the serializer to handling unsupported, parse, and once it's done
            // serializing the output of unSupported, set it back to false.
            this._handlingUnsupported = true;
            this.parse(this.onUnsupported(value));
            this._handlingUnsupported = false;
            return;
        }
        // If no handler is available, throw TypeError
        throw new SerializerError_1.SerializerError(`Unsupported type '${hint}'.`, SerializerError_1.SerializerReason.UnsupportedType);
    }
    parseBigInt(value) {
        const sign = value >= util_1.BigIntegers.ZERO ? 0 : 1;
        this.ensureAlloc(5);
        this.write8(sign ? constants_1.BinaryTokens.NBigInt : constants_1.BinaryTokens.PBigInt);
        const headerOffset = this._offset;
        this._offset += 4;
        let unsignedBigInt = sign === 1 ? -value : value;
        let byteCount = 0;
        while (unsignedBigInt > 0) {
            ++byteCount;
            this.write8(Number(unsignedBigInt & util_1.BigIntegers.BYTE));
            unsignedBigInt >>= util_1.BigIntegers.EIGHT;
        }
        this.write32At(byteCount, headerOffset);
    }
    parseBoolean(value) {
        this.write8(constants_1.BinaryTokens.Boolean);
        this.write8(value ? 1 : 0);
    }
    parseNumber(value) {
        const type = this.getNumberType(value);
        this.write8(type);
        /* istanbul ignore next: This prints an erroneous coverage result. Definitely must be checked in the future. */
        switch (type) {
            case constants_1.BinaryTokens.SignedByte:
                this.write8(-value);
                break;
            case constants_1.BinaryTokens.UnsignedByte:
                this.write8(value);
                break;
            case constants_1.BinaryTokens.SignedInt32:
                this.write32(-value);
                break;
            case constants_1.BinaryTokens.UnsignedInt32:
                this.write32(value);
                break;
            case constants_1.BinaryTokens.SignedFloat64:
                this.writeF64(-value);
                break;
            case constants_1.BinaryTokens.UnsignedFloat64:
                this.writeF64(value);
                break;
            default:
                /* istanbul ignore next */
                throw new Error(`Unreachable code. Got unexpected integer type ${type}`);
        }
    }
    parseObject(value) {
        if (value === null)
            return this.parseValueNull();
        // Circular reference detection
        const id = this._objectIDs.get(value);
        if (typeof id === 'number')
            return this.parseValueReference(id);
        // Set this object to the reference list
        this._objectIDs.set(value, this._objectIDs.size);
        // If it's an array, parse it
        if (Array.isArray(value))
            return this.parseValueArray(value);
        // We're doing this because it's safer for the context where you
        // extend the classes.
        const tag = Object.prototype.toString.call(value);
        /* istanbul ignore next: This prints an erroneous coverage result. Definitely must be checked in the future. */
        switch (tag) {
            // eslint-disable-next-line @typescript-eslint/ban-types
            case '[object String]': return this.parseValueObjectString(value);
            // eslint-disable-next-line @typescript-eslint/ban-types
            case '[object Boolean]': return this.parseValueObjectBoolean(value);
            // eslint-disable-next-line @typescript-eslint/ban-types
            case '[object Number]': return this.parseValueObjectNumber(value);
            case '[object Date]': return this.parseValueObjectDate(value);
            case '[object RegExp]': return this.parseValueObjectRegExp(value);
            case '[object Object]': return this.parseValueObjectLiteral(value);
            case '[object Map]': return this.parseValueObjectMap(value);
            case '[object Set]': return this.parseValueObjectSet(value);
            case '[object ArrayBuffer]': return this.parseValueObjectArrayBuffer(value);
            case '[object WeakMap]': return this.parseValueObjectWeakMap();
            case '[object WeakSet]': return this.parseValueObjectWeakSet();
            case '[object Promise]': return this.handleUnsupported(value, 'object');
            default: return this.parseValueObjectFallback(value, tag);
        }
    }
    parseString(value) {
        this.write8(constants_1.BinaryTokens.String);
        this.writeValueString(value);
    }
    parseUndefined() {
        this.write8(constants_1.BinaryTokens.Undefined);
    }
    parseValueNull() {
        this.write8(constants_1.BinaryTokens.Null);
    }
    // eslint-disable-next-line @typescript-eslint/ban-types
    parseValueObjectString(value) {
        this.write8(constants_1.BinaryTokens.StringObject);
        this.writeValueString(value.valueOf());
    }
    // eslint-disable-next-line @typescript-eslint/ban-types
    parseValueObjectBoolean(value) {
        this.write8(constants_1.BinaryTokens.BooleanObject);
        this.write8(value.valueOf() ? 1 : 0);
    }
    // eslint-disable-next-line @typescript-eslint/ban-types
    parseValueObjectNumber(value) {
        this.write8(constants_1.BinaryTokens.NumberObject);
        this.writeF64(value.valueOf());
    }
    parseValueObjectDate(value) {
        this.write8(constants_1.BinaryTokens.Date);
        this.writeF64(value.valueOf());
    }
    parseValueObjectRegExp(value) {
        this.write8(constants_1.BinaryTokens.RegExp);
        this.writeValueString(value.source);
        this.write8(util_1.RegExps.flagsAsInteger(value));
    }
    parseValueObjectLiteral(value) {
        const keys = Object.keys(value);
        if (keys.length === 0) {
            return this.write8(constants_1.BinaryTokens.EmptyObject);
        }
        this.write8(constants_1.BinaryTokens.Object);
        for (const entryKey of keys) {
            this.parse(entryKey);
            this.parse(value[entryKey]);
        }
        this.write8(constants_1.BinaryTokens.NullPointer);
    }
    parseValueObjectMap(value) {
        if (value.size === 0) {
            return this.write8(constants_1.BinaryTokens.EmptyMap);
        }
        this.write8(constants_1.BinaryTokens.Map);
        for (const [entryKey, entryValue] of value.entries()) {
            this.parse(entryKey);
            this.parse(entryValue);
        }
        this.write8(constants_1.BinaryTokens.NullPointer);
    }
    parseValueObjectSet(value) {
        if (value.size === 0) {
            return this.write8(constants_1.BinaryTokens.EmptySet);
        }
        this.write8(constants_1.BinaryTokens.Set);
        for (const entryValue of value) {
            this.parse(entryValue);
        }
        this.write8(constants_1.BinaryTokens.NullPointer);
    }
    parseValueObjectArrayBuffer(value) {
        this.write8(constants_1.BinaryTokens.ArrayBuffer);
        const uint8Array = new Uint8Array(value);
        this.write32(uint8Array.length);
        this.write(uint8Array);
    }
    parseValueObjectWeakMap() {
        this.write8(constants_1.BinaryTokens.WeakMap);
    }
    parseValueObjectWeakSet() {
        this.write8(constants_1.BinaryTokens.WeakSet);
    }
    parseValueObjectFallback(value, tag) {
        const typedArrayTag = util_1.TypedArrays.typedArrayTags.get(tag);
        if (typedArrayTag)
            this.writeValueTypedArray(value, typedArrayTag);
        else
            this.parseValueObjectLiteral(value);
    }
    parseValueReference(value) {
        this.write8(constants_1.BinaryTokens.ObjectReference);
        this.write32(value);
    }
    parseValueArray(value) {
        if (value.length === 0) {
            return this.write8(constants_1.BinaryTokens.EmptyArray);
        }
        this.ensureAlloc(2);
        this.write8(constants_1.BinaryTokens.Array);
        for (let i = 0, n = value.length; i < n; i++) {
            if (i in value) {
                this.parse(value[i]);
            }
            else {
                this.write8(constants_1.BinaryTokens.Hole);
            }
        }
        this.write8(constants_1.BinaryTokens.NullPointer);
    }
    writeValueTypedArray(value, tag) {
        this.write8(tag);
        this.write32(value.byteLength);
        if (tag !== constants_1.BinaryTokens.Uint8Array) {
            value = new Uint8Array(value.buffer);
        }
        this.write(value);
    }
    write(value) {
        this.ensureAlloc(value.byteLength);
        this._buffer.set(value, this._offset);
        this._offset += value.byteLength;
    }
    write8(value) {
        this.ensureAlloc(1);
        this._buffer[this._offset++] = value;
    }
    write32(value) {
        this.ensureAlloc(4);
        this.write32At(value, this._offset);
        this._offset += 4;
    }
    write32At(value, offset) {
        this._buffer[offset + 3] = value;
        value >>>= 8;
        this._buffer[offset + 2] = value;
        value >>>= 8;
        this._buffer[offset + 1] = value;
        value >>>= 8;
        this._buffer[offset] = value;
    }
    writeF64(value) {
        float64Array[0] = value;
        this.write(uInt8Float64Array);
    }
    writeValueString(value) {
        const serialized = Serializer._textEncoder.encode(value);
        // Strings must not contain a null pointer, since they are null-delimited.
        if (serialized.includes(constants_1.BinaryTokens.NullPointer)) {
            throw new SerializerError_1.SerializerError('Unexpected null pointer in serialized string.', SerializerError_1.SerializerReason.UnexpectedNullValue);
        }
        this.write(serialized);
        this.write8(constants_1.BinaryTokens.NullPointer);
    }
    getNumberType(value) {
        const sign = value < 0;
        if (value % 1 === 0) {
            // Byte (S | U)
            if (value >= MIN_INT8 && value <= MAX_INT8)
                return sign ? constants_1.BinaryTokens.SignedByte : constants_1.BinaryTokens.UnsignedByte;
            // Int32 (S | U)
            if (value >= MIN_INT32 && value <= MAX_INT32)
                return sign ? constants_1.BinaryTokens.SignedInt32 : constants_1.BinaryTokens.UnsignedInt32;
            // Fallback to float
        }
        // Float64
        return sign ? constants_1.BinaryTokens.SignedFloat64 : constants_1.BinaryTokens.UnsignedFloat64;
    }
    ensureAlloc(amount) {
        this.expandBuffer(this._offset + amount);
    }
    expandBuffer(length) {
        if (this._buffer.length < length) {
            const old = this._buffer;
            this._buffer = new Uint8Array(util_1.Numbers.nextPowerOfTwo(length));
            this._buffer.set(old);
        }
    }
}
Serializer._textEncoder = new util_2.TextEncoder();
exports.Serializer = Serializer;
//# sourceMappingURL=Serializer.js.map